import networkx as nx
import pickle
import os
from itertools import combinations


class network_and_ontology_store:
    """
    This class facilitates ontology condensation during inference and manages the loading and storing
    of data generated by the "network_creation_and_shacl_ontology_retriever.py" script.
    (e.g., the pre-computed GTOC results)
    """

    def __init__(self, k_shortest_routes):
        """
        Initializes an instance of the `network_and_ontology_store` class and loads all required data into the instance.

        :param k_shortest_routes:
            int: The number of shortest routes to consider between relevant nodes during the GTOC process.
        """

        # Set main path from which we will load files.
        current_dir = os.path.dirname(os.path.abspath(__file__))
        main_path = os.path.join(current_dir, '../precompute_shortest_routes/saved_data/')

        # Load the NetworkX graph network.
        self.network = nx.read_graphml(main_path + "network_graph.graphml")

        '''
        Dictionary: A mapping where the keys are SORTED tuples representing ADJACENT nodes in the graph network
        (e.g., ('node1', 'node2')), and the values are lists of ontology triples (formatted as strings, for
        example: "node1 property node2") that describe the relationships enabling traversal between these nodes.
        Since we do not store properties in the NetworkX `DiGraph` , this dictionary provides a way to
        capture and reference the specific ontology properties used for traversing between adjacent nodes.
        IMPORTANT: the tuple keys are SORTED.
        '''
        with open(main_path + 'ontology_triples_matched_with_network_in_dict.pickle', 'rb') as f:
            edge_labels = pickle.load(f)
        self.ontology_triples_belonging_to_edge = edge_labels

        # Load list with all classes.
        with open(main_path + 'classes.pickle', 'rb') as f:
            classes = pickle.load(f)
        self.classes = classes

        # Load list with all properties.
        with open(main_path + 'relations.pickle', 'rb') as f:
            relations = pickle.load(f)
        self.relations = relations

        '''
        This dictionary defines commonly used URI prefixes along with their corresponding shorthand notations.
        These prefixes are used to simplify references to entities in various ontologies, 
        enabling concise and readable SPARQL queries.
        '''
        with open(main_path + 'prefix_dictionary.pickle', 'rb') as f:
            prefix_dictionary = pickle.load(f)
        self.prefix_dictionary = prefix_dictionary

        '''
        A single string containing PREFIX declarations which can be prepended to SPARQL queries.
        These declarations define shorthand notations (prefixes) for full URIs, 
        allowing more concise and readable SPARQL queries.
        '''
        with open(main_path + 'prefix_string.pickle', 'rb') as f:
            prefix_string = pickle.load(f)
        self.prefix_string = prefix_string.replace('cbs:', 'wbk:')

        '''
        NOTE: This dictionary contains the following keys:
        - `datatype_edges`
        - `object_edges`
        - `object_edges_with_restrictions`
        - `subclass_edges`

        The corresponding values are lists of tuples. Each tuple represents an edge and contains
        three strings in the format: 
        ('class', 'relation', 'class/datatype').
        '''
        with open(main_path + 'all_edges_dictionary.pickle', 'rb') as f:
            all_edges = pickle.load(f)
        self.all_edges_dictionary = all_edges

        '''
        Load a single string where each class or value-list entity is listed on a new line.
        This is useful in the prompt for selecting relevant classes and value-list entities.
        '''
        with open(main_path + 'classes_without_comments_string.pickle', 'rb') as f:
            classes_without_comments_string = pickle.load(f)
        self.classes_without_comments_string = classes_without_comments_string

        '''
        Load a single string where each property is listed on a new line.
        This is useful in the prompt for selecting relevant properties.
        '''
        with open(main_path + 'relations_without_comments_string.pickle', 'rb') as f:
            relations_without_comments_string = pickle.load(f)
        self.relations_without_comments_string = relations_without_comments_string

        '''
        Load a dictionary used to find neighboring nodes of relevant relations in the ontology.
        - Keys: All the relations (properties) in the ontology.
        - Values: Sets containing all nodes that are neighbors of the respective relation.
        '''
        with open(main_path + 'dictionary_that_maps_property_to_neighboring_nodes', 'rb') as f:
            loaded_data = pickle.load(f)
        self.dictionary_that_maps_property_to_neighboring_nodes = loaded_data

        '''
        Load the pre-computed GTOC (Graph Traversal Ontology Condensation) results.

        This method loads the dictionary corresponding to the specified number of shortest routes (`k_shortest_routes`)
        provided in the constructor.

        Dictionary format:
        - **Keys**: Tuples representing pairs of ontology network nodes, e.g., ("element1", "element2").
        - **Values**: Lists of ontology triples (in string format) required for the `k_shortest_routes` between the nodes. 
          Example of such a list:
          ["element_a property1 element_b", "element_b property2 element_c"].
        '''
        main_path = os.path.join(current_dir,
                                 '../precompute_shortest_routes/saved_network_and_ontology/dictionaries_that_map_pairs_of_nodes_to_ontology_items/')
        path = 'dictionary_that_maps_all_pairs_to_the_necessary_ontology_items_in_top_%s_shortest_routes' % (
            str(k_shortest_routes))
        with open(main_path + path, 'rb') as f:
            loaded_data = pickle.load(f)
        self.dictionary_that_maps_all_pairs_to_the_necessary_ontology_items_in_top_k_shortest_routes = loaded_data


        '''
        A dictionary mapping each property to a set of vertex-edge pairs.

        - **Keys**: Properties in the ontology.
        - **Values**: Sets containing vertex-edge pairs represented as strings in the format 
          "element1 property element2", indicating all instances where the property is involved.
        '''
        main_path = os.path.join(current_dir, '../precompute_shortest_routes/saved_network_and_ontology/')
        with open(main_path + 'dictionary_that_maps_property_to_all_ontology_triples_as_string', 'rb') as f:
            loaded_data = pickle.load(f)
        self.dictionary_that_maps_property_to_all_ontology_triples_as_string = loaded_data

    def print_classes(self):
        print(self.classes)

    def print_relations(self):
        print(self.relations)

    def print_datatype_edges(self):
        for edge in self.all_edges_dictionary['datatype_edges']:
            print(edge)

    def print_object_edges(self):
        for edge in self.all_edges_dictionary['object_edges']:
            print(edge)

    def print_object_edges_with_restrictions(self):
        for edge in self.all_edges_dictionary['object_edges_with_restrictions']:
            print(edge)

    def print_subclass_edges(self):
        for edge in self.all_edges_dictionary['subclass_edges']:
            print(edge)

    def get_classes(self):
        return self.classes

    def get_relations(self):
        return self.relations

    def print_all_edges_in_graph(self):
        for edge in self.network.edges:
            print(edge)

    def condense_ontology_based_on_retrieved_schema_items(self, retrieved_classes, retrieved_relations):
        """
        Condenses the ontology schema into a smaller subset tailored to specific natural language
        questions using GTOC (Graph Traversal Ontology Condensation), and returns the condensed
        ontology.

        :param retrieved_classes:
            List of relevant classes and value-list entities.

        :param retrieved_relations:
            List of relevant properties.

        :return:
            tuple: A tuple containing two strings:
                - The first string holds all object vertex-edge pairs in the condensed graph,
                  with each pair on a new line.
                - The second string holds all datatype vertex-edge pairs in the condensed graph,
                  each on a new line.
        """
        # We initialize a set which will hold all vertex-edge pairs in the condensed ontology
        triples_set = set()

        # The retrieved classes and value-list entities are always relevant nodes.
        nodes_obtained_from_retrieved_classes = retrieved_classes
        # We intitialize a set which will hold all nodes adjacent to the retrieved properties.
        nodes_obtain_from_retrieved_relations = set()
        for rel in retrieved_relations:
            # All vertex-edge pairs containing any of the relevant properties must be included in GTOC.
            # Therefore, we add them directly here.
            if rel in self.dictionary_that_maps_property_to_all_ontology_triples_as_string:
                for triple in self.dictionary_that_maps_property_to_all_ontology_triples_as_string[rel]:
                    triples_set.add(triple)

            # We obtain all nodes surrounding the retrieved properties.
            neighbor_nodes = self.dictionary_that_maps_property_to_neighboring_nodes.get(rel, [])
            for node in neighbor_nodes:
                nodes_obtain_from_retrieved_relations.add(node)
        nodes_obtain_from_retrieved_relations = list(nodes_obtain_from_retrieved_relations)

        all_nodes = nodes_obtained_from_retrieved_classes + nodes_obtain_from_retrieved_relations

        # all_nodes is a list with all unique relevant nodes.
        all_nodes = list(set(all_nodes))
        # Generate all unordered pairs
        unordered_pairs = list(combinations(all_nodes, 2))

        # Sort the pairs alphabetically
        sorted_pairs = sorted([tuple(sorted(pair)) for pair in unordered_pairs])

        for pair in sorted_pairs:
            # simple check, making sure we do not try to find paths between two datatype edges
            if 'xsd:' not in pair[0] and 'xsd:' not in pair[1]:
                if tuple(sorted(pair)) in self.dictionary_that_maps_all_pairs_to_the_necessary_ontology_items_in_top_k_shortest_routes:
                    for ontology_triple in self.dictionary_that_maps_all_pairs_to_the_necessary_ontology_items_in_top_k_shortest_routes[pair]:
                        triples_set.add(ontology_triple)

        ontology_string_object_part = ""
        ontology_string_datatype_part = ""

        '''
        Here we remove certain triples that should not exist in the ontology. Specifically, "gebruiksdoel" 
        should only be defined on "sor:Verblijfsobject", not on "sor:Gebouwzone".
        This data quality issue has been confirmed by employees of the Dutch Land Registry (Kadaster).
        '''
        triples_to_remove = {'sor:Gebouwzone sor:gebruiksdoel sor-con:bijeenkomstfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:celfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:gezondheidsfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:industriefunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:kantoorfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:logiesfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:onderwijsfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:sportfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:winkelfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:woonfunctie'}
        triples_set = triples_set.difference(triples_to_remove)
        triples_set = sorted(triples_set)

        for ontology_triple in triples_set:
            if 'xsd:' in ontology_triple:
                ontology_string_datatype_part += "%s\n" % ontology_triple
            else:
                ontology_string_object_part += "%s\n" % ontology_triple

        return ontology_string_object_part, ontology_string_datatype_part

    def naive_ontology_selection(self, retrieved_classes, retrieved_relations):
        """
        Condenses the ontology schema into a smaller subset tailored to specific natural language
        questions using NAIVE ontology condensation, and returns the condensed
        ontology.

        :param retrieved_classes:
            List of relevant classes and value-list entities.

        :param retrieved_relations:
            List of relevant properties.

        :return:
            tuple: A tuple containing two strings:
                - The first string holds all object vertex-edge pairs in the condensed graph,
                  with each pair on a new line.
                - The second string holds all datatype vertex-edge pairs in the condensed graph,
                  each on a new line.
        """
        triples_set = set()

        # First we select all ontology triples that include the retrieved relations
        for rel in retrieved_relations:
            if rel in self.dictionary_that_maps_property_to_all_ontology_triples_as_string:
                for triple in self.dictionary_that_maps_property_to_all_ontology_triples_as_string[rel]:
                    triples_set.add(triple)

        # Next we select the ontology triples that include the retrieved classes
        for cls in retrieved_classes:
            for edge in self.all_edges_dictionary['datatype_edges']:
                if cls == edge[0]:
                    triples_set.add("%s %s %s" % (edge[0], edge[1], edge[2]))

            for edge in self.all_edges_dictionary['object_edges']:
                if cls == edge[0] or cls == edge[2]:
                    triples_set.add("%s %s %s" % (edge[0], edge[1], edge[2]))

            for edge in self.all_edges_dictionary['object_edges_with_restrictions']:
                if cls == edge[0] or cls == edge[2]:
                    triples_set.add("%s %s %s" % (edge[0], edge[1], edge[2]))

        ontology_string_object_part = ""
        ontology_string_datatype_part = ""

        '''
        Here we remove certain triples that should not exist in the ontology. Specifically, "gebruiksdoel" 
        should only be defined on "sor:Verblijfsobject", not on "sor:Gebouwzone".
        This data quality issue has been confirmed by employees of the Dutch Land Registry (Kadaster).
        '''
        triples_to_remove = {'sor:Gebouwzone sor:gebruiksdoel sor-con:bijeenkomstfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:celfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:gezondheidsfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:industriefunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:kantoorfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:logiesfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:onderwijsfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:sportfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:winkelfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:woonfunctie'}
        triples_set = triples_set.difference(triples_to_remove)
        triples_set = sorted(triples_set)

        for ontology_triple in triples_set:
            if 'xsd:' in ontology_triple:
                ontology_string_datatype_part += "%s\n" % ontology_triple
            else:
                ontology_string_object_part += "%s\n" % ontology_triple

        return ontology_string_object_part, ontology_string_datatype_part

    def retrieve_full_ontology(self):
        """
        Returns the entire ontology without applying condensation.

        :return:
            tuple: A tuple containing two strings:
                - The first string holds all object vertex-edge pairs in the entire ontology,
                  each on a new line
                - The second string holds all datatype vertex-edge pairs in the entire ontology,
                  each on a new line.
        """
        triples_set = set()

        for edge in self.all_edges_dictionary['datatype_edges']:
            triples_set.add("%s %s %s" % (edge[0], edge[1], edge[2]))

        for edge in self.all_edges_dictionary['object_edges']:
            triples_set.add("%s %s %s" % (edge[0], edge[1], edge[2]))

        for edge in self.all_edges_dictionary['object_edges_with_restrictions']:
            triples_set.add("%s %s %s" % (edge[0], edge[1], edge[2]))

        ontology_string_object_part = ""
        ontology_string_datatype_part = ""

        '''
        Here we remove certain triples that should not exist in the ontology. Specifically, "gebruiksdoel" 
        should only be defined on "sor:Verblijfsobject", not on "sor:Gebouwzone".
        This data quality issue has been confirmed by employees of the Dutch Land Registry (Kadaster).
        '''
        triples_to_remove = {'sor:Gebouwzone sor:gebruiksdoel sor-con:bijeenkomstfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:celfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:gezondheidsfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:industriefunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:kantoorfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:logiesfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:onderwijsfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:sportfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:winkelfunctie',
                             'sor:Gebouwzone sor:gebruiksdoel sor-con:woonfunctie'}
        triples_set = triples_set.difference(triples_to_remove)
        triples_set = sorted(triples_set)

        for ontology_triple in triples_set:
            if 'xsd:' in ontology_triple:
                ontology_string_datatype_part += "%s\n" % ontology_triple
            else:
                ontology_string_object_part += "%s\n" % ontology_triple

        return ontology_string_object_part, ontology_string_datatype_part


store = network_and_ontology_store(1)

network_nodes = set(store.network.nodes())
classes = set(store.classes)
print(classes.difference(network_nodes))
print(network_nodes.difference(classes))

